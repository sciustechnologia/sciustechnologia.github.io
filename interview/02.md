## testing mobile apps

> Showcase my ability to test mobile apps on iOS (and Android - with focus on testing different types of functionalities)

     * E-commerce flows,
     * user interface

## I. Setting the Stage (Regardless of OS)

### Understanding Requirements:
* The absolute foundation. What's the app *supposed* to do?  
* User stories, design documents, specifications, and conversations with developers/product owners are your sources.  
* Ambiguity kills testing efforts.

### Test Environment Setup:

1. Real Devices (Essential).  
  * Use a range of devices with different screen sizes, OS versions (focus on the most popular and the minimum supported), and hardware specs. Consider a device lab (physical or cloud-based).
  * Emulators/Simulators:
  	* Useful for initial testing and automation development. 
  	* Android Studio's emulator for Android. 
  	* Xcode's simulator for iOS. 
  	
  	> *never* rely solely on emulators; they don't perfectly replicate real-world device behavior.
  	
2. Network Conditions:
  	* Mimic different network speeds (Wi-Fi, 4G, 3G, Edge). 
  	* Use tools like Network Link Conditioner (macOS) or Android's Developer Options to throttle bandwidth and simulate packet loss.
  	
3. Background Apps:
  	* Run common background apps (music streaming, email, location services) to simulate real-world memory pressure and potential conflicts.
    * Test Data: Prepare realistic and comprehensive test data.  Consider using a test database or API endpoint to avoid impacting production data.

### Test Plan:
* Outline your testing strategy, scope, objectives, timelines, and resource allocation.
* *[Agile Test  plan](https://trumpfheller.github.io/playbook/03.html)

## II. Key Testing Areas (Android & iOS, with Android Emphasis)

> breakdown by functionality, with considerations for both platforms but tailored more towards Android:

### A. Functionality (Core Logic)

*   **E-commerce Flows (Adding to Cart, Checkout, Payment Processing):**
    *   **Android & iOS:**
        *   **Happy Path:** Successful order placement, payment processing, order confirmation.
        *   **Edge Cases:**
            *   Invalid input (e.g., incorrect credit card number, expiry date).
            *   Insufficient funds.
            *   Expired promo codes.
            *   Item out of stock *during* checkout.
            *   Address validation failures.
            *   Connectivity issues during payment.
        *   **Error Handling:**  Graceful error messages and appropriate recovery actions.  No crashes!
        *   **Security:**
            *   Encryption of sensitive data (credit card details).
            *   Protection against MITM (Man-in-the-Middle) attacks.
            *   Compliance with PCI DSS standards (if applicable).
        *   **Android Specific:**
            *   Test with different payment methods (Google Pay, etc.).
            *   Handling different screen sizes and resolutions during the checkout flow.
*   **User Authentication (Login, Registration, Password Reset):**
    *   **Android & iOS:**
        *   **Valid/Invalid Credentials:** Test with correct and incorrect usernames and passwords.
        *   **Password Complexity:** Enforce and test password complexity rules.
        *   **Account Lockout:**  Test account lockout after multiple failed login attempts.
        *   **Two-Factor Authentication (2FA):** Test 2FA setup and login flows.
        *   **Social Login (Google, Facebook):** Test integration with social login providers.
        *   **Password Reset:** Verify password reset functionality (email/SMS).
        *   **Session Management:**  Test session timeouts and handling of multiple active sessions.
    *   **Android Specific:**
        *   Test with different authentication methods (fingerprint, face unlock).
*   **Data Synchronization (Cloud Sync, Offline Mode):**
    *   **Android & iOS:**
        *   **Initial Sync:** Test the initial data synchronization process.
        *   **Incremental Sync:** Verify that only new or changed data is synchronized.
        *   **Conflict Resolution:**  Test how the app handles data conflicts between local and cloud storage.
        *   **Offline Functionality:** Test the app's behavior when offline (e.g., can users still browse cached data?).
        *   **Background Sync:** Verify that background synchronization works as expected.
    *   **Android Specific:**
        *   Test with different background data restrictions (battery saver mode, data saver mode).
*   **Push Notifications:**
    *   **Android & iOS:**
        *   **Delivery:**  Verify that notifications are delivered promptly and reliably.
        *   **Content:** Check that the notification content is accurate and informative.
        *   **Actions:** Test the actions associated with notifications (e.g., tapping a notification opens the app).
        *   **Notification Settings:**  Verify that users can customize notification settings.
        *   **Background Delivery:** Test notification delivery when the app is in the background or closed.
    *   **Android Specific:**
        *   Test with different notification channels (Android 8.0+).
        *   Verify that notifications are displayed correctly on different Android versions.

### B. User Interface (UI) Testing

*   **Android & iOS:**
    *   **Visual Layout:**
        *   **Screen Size Compatibility:** Test on various screen sizes and resolutions to ensure UI elements are properly sized and positioned.
        *   **Orientation Changes:**  Verify that the UI adapts correctly to portrait and landscape orientations.
        *   **Text Overflow:**  Prevent text from overflowing its containers.
        *   **Alignment and Spacing:** Check for consistent alignment and spacing between UI elements.
    *   **Usability:**
        *   **Intuitive Navigation:**  Ensure the app is easy to navigate.
        *   **Clear Labels and Instructions:**  Provide clear and concise labels and instructions.
        *   **Accessibility:**  Follow accessibility guidelines (e.g., provide alternative text for images, ensure sufficient color contrast).  Use accessibility tools to verify compliance.
        *   **Responsiveness:** The UI should respond quickly to user input.
    *   **Android & iOS (Different implementations):**
        *   **Themeing (Light/Dark Mode):** Verify that the app's UI adapts correctly to different themes.
    *   **Android Specific:**
        *   Test with different display densities (dpi).
        *   Test with different keyboard layouts.
        *   Check for proper handling of Android UI components (e.g., Material Design components).

### C. Performance Testing

*   **Android & iOS:**
    *   **App Launch Time:** Measure the time it takes for the app to launch.
    *   **Memory Usage:**  Monitor the app's memory consumption.
    *   **CPU Usage:** Track the app's CPU usage.
    *   **Battery Consumption:** Analyze the app's battery drain.
    *   **Scrolling Performance:**  Ensure smooth scrolling in lists and other scrollable views.
    *   **Network Performance:**  Measure network latency and throughput.
*   **Tools:** Android Studio Profiler, Xcode Instruments, third-party performance monitoring tools.

### D. Network Connectivity Testing

*   **Android & iOS:**
    *   **Connectivity Loss:**  Test how the app handles loss of network connectivity.
    *   **Network Switching:** Verify that the app recovers gracefully from network switching (e.g., Wi-Fi to cellular).
    *   **Data Usage:**  Monitor the app's data usage.
    *   **Proxy Settings:** Test the app's behavior with different proxy settings.
    *   **Secure Connections (HTTPS):**  Ensure that all network communication is encrypted using HTTPS.

### E. Security Testing

*   **Android & iOS:**
    *   **Data Storage:**  Verify that sensitive data is stored securely.
    *   **Code Security:**  Protect against code injection and other code-level vulnerabilities.
    *   **Permissions:**  Ensure that the app only requests necessary permissions.
    *   **Third-Party Libraries:**  Scan third-party libraries for known vulnerabilities.
    *   **Penetration Testing:**  Conduct penetration testing to identify security flaws.
*   **Tools:** Static analysis tools, dynamic analysis tools, penetration testing tools.

### F. Installation and Update Testing (Android Specific - iOS is more controlled)

*   **Android:**
    *   **Installation from Different Sources:** Google Play Store, APK files.
    *   **Update Process:**  Test the update process from different versions of the app.
    *   **Uninstall Process:**  Verify that the app is completely uninstalled.
    *   **Permissions During Installation/Update:** Ensure proper handling of permission requests.
    *   **Storage Space:** Verify that the app has sufficient storage space to install and run.
    *   **Android App Bundles:**  Test with Android App Bundles to ensure that the correct resources are delivered to different devices.

## III. Testing Methodologies

*   **Manual Testing:**  Traditional hands-on testing.
*   **Automated Testing:** Using tools and scripts to automate repetitive tasks.  Crucial for regression testing.  Frameworks: Appium, Espresso (Android), XCUITest (iOS).
*   **Exploratory Testing:**  Simultaneous learning, test design, and test execution.  Good for uncovering unexpected issues.
*   **Beta Testing:**  Releasing the app to a limited group of users for feedback before the official launch.
*   **A/B Testing:** Testing different versions of the app to see which performs better.

## IV. Android-Specific Considerations

*   **Fragmentation:**  The biggest challenge on Android.  Test on a wide range of devices and OS versions.
*   **Custom ROMs:**  Consider testing on popular custom ROMs.
*   **Manufacturer Modifications:** Be aware that manufacturers often modify the Android OS, which can impact app behavior.
*   **Permissions Model:**  Android's runtime permissions model requires careful testing.
*   **Background Execution Limits:** Android has restrictions on background execution, which can affect tasks like data synchronization and push notifications.  Thoroughly test background functionality.

## V. Important Notes

*   **Prioritize Risk:** Focus your testing efforts on the areas of the app that are most critical to its success.
*   **Regression Testing:**  Run regression tests after every code change to ensure that new code doesn't break existing functionality.
*   **Defect Tracking:**  Use a defect tracking system to manage and track bugs.
*   **Collaboration:**  Communicate effectively with developers and product owners throughout the testing process.
*   **Continuous Integration/Continuous Delivery (CI/CD):** Integrate testing into your CI/CD pipeline to automate testing and accelerate the release cycle.
*   **Logging and Monitoring:**  Implement logging and monitoring to track app performance and identify issues in production.
*   **Always be learning:** The mobile landscape is constantly evolving. Stay up-to-date with the latest testing tools, techniques, and best practices.

---

###  simplified explanation of automated app testing (Android focus)

Objective: To detect regression automate UI interactions by validating app functionality.

Appium Framework: A cross-platform automation framework, acting as a server accepting commands (e.g., in Java or Python). It's like Selenium, but for mobile.

WebDriver Protocol: Appium uses the WebDriver protocol to communicate with the mobile device or emulator. This is the same protocol Selenium uses for web browsers.

Element Location Strategies: Identifying UI elements is crucial. Methods include:

resource-id (Android): The preferred method for Android; analogous to HTML id. e.g., driver.findElement(By.id("com.example.app:id/login_button"))

Accessibility ID: Uses content descriptions (important for accessibility).

XPath: A powerful but potentially fragile approach if the UI structure changes. E.g., driver.findElement(By.xpath("//android.widget.Button[@text='Login']"))

UIAutomator (Android): Android's own testing framework offers fine-grained control but is more complex to implement directly.

Test Script Structure: Scripts are written in a language like Java or Python. Typical steps: Launch app -> Locate element -> Interact (click, send keys) -> Assert/Verify result.

Assertions: Validating that the app behaves as expected. Examples: Assert.assertEquals(expectedText, actualText); or Assert.assertTrue(element.isDisplayed());

Device Setup (Android Example): Requires an Android emulator or real device configured for USB debugging. Also needs the Android SDK.

Desired Capabilities: Configuration details (e.g., platform name, device name, app package, app activity) passed to Appium to launch the app under test. These tell Appium what to control.

Execution: Appium server receives commands, translates them into native mobile commands (UIAutomator for Android), and executes them on the device.

Reporting: Test results are generated, indicating pass/fail status for each test case. Integrate with reporting tools for dashboards and trend analysis.


Reporting: Test results are generated, indicating pass/fail status for each test case. Integrate with reporting tools for dashboards and trend analysis.

### Now the same technical explanation, with a comparison to XCUITest for iOS:

1.  **Objective:** Automate UI interactions to validate app functionality and detect regressions. (Same for both Android and iOS).

2.  **Automation Framework (Android vs iOS):**
    *   **Android:** Appium framework (cross-platform), acting as a server, accepts commands (e.g., in Java or Python). WebDriver protocol.
    *   **iOS:** XCUITest framework (Apple's native framework). Integrated directly into Xcode. Uses Swift or Objective-C.  Less setup than Appium.

3.  **Communication Protocol (Android vs iOS):**
    *   **Android:** Appium uses WebDriver protocol to communicate with the mobile device or emulator.
    *   **iOS:** XCUITest uses Apple's internal communication mechanism. It directly instruments the app, making it faster and more reliable (generally) than Appium.

4.  **Element Location Strategies (Android vs iOS):** Identifying UI elements.
    *   **Android:**
        *   `resource-id` (preferred)
        *   `Accessibility ID`
        *   `XPath` (fragile)
        *   `UIAutomator` (complex, powerful)
    *   **iOS:**
        *   `Accessibility Identifier` (preferred, like `resource-id`)
        *   `Predicate`: Powerful string-based search.
        *   `XPath`:  Less reliable than on Android.
        *   `UIAutomation`: Apple's older framework; now deprecated in favor of XCUITest.

5.  **Test Script Structure (Android vs iOS):**
    *   **Android:** Scripts are written in a language like Java or Python. Typical steps: Launch app -> Locate element -> Interact (click, send keys) -> Assert/Verify result.
    *   **iOS:** Scripts written in Swift or Objective-C. Same logical steps as Android, but the syntax and API are different.

6.  **Assertions (Android vs iOS):** Validating app behavior.
    *   **Android:** `Assert.assertEquals(expectedText, actualText);`, `Assert.assertTrue(element.isDisplayed());` (using JUnit)
    *   **iOS:** `XCTAssertEqual(expectedText, actualText);`, `XCTAssertTrue(element.isDisplayed());` (using XCTest)

7.  **Device Setup (Android vs iOS):**
    *   **Android:** Requires Android emulator/real device + USB debugging + Android SDK.
    *   **iOS:** Requires Xcode + iOS simulator/real device.  Device needs to be provisioned with appropriate certificates.

8.  **Desired Capabilities / Test Configuration (Android vs iOS):**
    *   **Android:** Desired Capabilities (platform name, device name, app package, app activity) passed to Appium.
    *   **iOS:** Test configuration within Xcode (target settings, scheme settings).  This defines the device, app, and other test parameters.

9.  **Execution (Android vs iOS):**
    *   **Android:** Appium server receives commands, translates to UIAutomator commands, executes on the device.
    *   **iOS:** XCUITest directly instruments the app on the device, executing test code.

10. **Reporting (Android vs iOS):**
    *   **Android:** Test results indicate pass/fail. Can integrate with reporting tools.
    *   **iOS:** Test results within Xcode. XCTest provides built-in reporting.  Can integrate with CI/CD tools.

---
     
### Testing Product Search and Results

**Scenario:** Verify that searching for an iPhone in the Apple Store app returns relevant results.
verify that searching for an **iPhone 15 Pro** in the Apple Store app returns relevant results.
## **Execution Flow**

1. Launch Apple Store app
2. Tap the search bar
3. Enter "iPhone 15 Pro" and press Enter
4. Wait for search results to load
5. Check if the first result appears within 5 seconds
6. Verify that "iPhone 15 Pro" is listed in search results

```Swift
import XCTest
# imports **XCTest**, Apple's official testing framework

class AppleStoreSearchTests: XCTestCase {
# creates a **test class** named `AppleStoreSearchTests`, which inherits from `XCTestCase`.
# Every UI test needs to be inside an `XCTestCase` subclass.

    let app = XCUIApplication()
	# `XCUIApplication()` represents the **Apple Store app** being tested.
    # This allows us to interact with UI elements, like tapping buttons or entering text.

    override func setUpWithError() throws {
        continueAfterFailure = false
        app.launch()
    }
	# `continueAfterFailure = false` 
    # → If a failure occurs, the test will `stop immediately` instead of continuing.
    # `app.launch()` → Launches the Apple Store app before every test.
    # this ensures each test starts from a fresh app launch, avoiding side effects from previous tests.

    override func tearDownWithError() throws {
        app.terminate()
    }
	# Teardown Method: `app.terminate()` → Closes the app after the test finishes.
    # Ensures **clean state** before running the next test.

    func testProductSearchResults() throws {
        // Ensure search bar exists and tap on it
        let searchField = app.searchFields["storeSearchBar"]
        XCTAssertTrue(searchField.exists, "Search bar should be available")
        searchField.tap()
        # Locate and Interact with the Search Bar
        # `app.searchFields["storeSearchBar"]` → Finds the search bar using its **accessibility identifier** (`storeSearchBar`).
        # `XCTAssertTrue(searchField.exists, "Search bar should be available")` → Confirms that the search bar exists before interacting with it.
        # `searchField.tap()`** → Simulates a user **tapping** on the search bar.
        # If the search bar doesn’t exist, the test **fails early** with a meaningful message.

        // Type the search term and press Enter
        searchField.typeText("iPhone 15 Pro\n")

        # Enter a Search Term: `searchField.typeText("iPhone 15 Pro\n")` → Types `"iPhone 15 Pro"` into the search bar and presses **Enter (`\n`)** to submit the search.
        # Simulates a user pressing the **return (Enter) key** to trigger the search.

        
        // Wait for results to load
        let firstResult = app.cells.element(boundBy: 0)
        XCTAssertTrue(firstResult.waitForExistence(timeout: 5), "Search results should be displayed")

        # `app.cells.element(boundBy: 0)` → Selects the **first search result** (cell at index `0` in the results list).
        # `firstResult.waitForExistence(timeout: 5)` → Waits **up to 5 seconds** for the first result to appear.
        # `XCTAssertTrue(...)` → Asserts that search results **actually appear**, ensuring the search worked.
        # The app may **take time to fetch results**, so we **wait** instead of failing immediately.

        
        // Verify the search results contain expected text
        XCTAssertTrue(firstResult.staticTexts["iPhone 15 Pro"].exists, "The first search result should be iPhone 15 Pro")

        # Checks that the first search result contains the text "iPhone 15 Pro".
        # Uses `staticTexts["iPhone 15 Pro"].exists` to verify the correct product is displayed.
        # Ensures the **search functionality works correctly** by confirming the expected product appears.
    }
}
```

* Uses `searchFields` accessibility identifier to locate the search bar.
* Ensures elements exist before interacting with them (`waitForExistence(timeout:)`).
* Checks that the first search result matches expectations.

###  Takeaways

* Use Accessibility Identifiers (`storeSearchBar`, `iPhone 15 Pro`) for reliability.
* Wait for elements to appear (`waitForExistence(timeout:)`) to prevent flaky tests.
* Assert UI elements exist before interacting to catch issues early.
* Follow a clean setup & teardown (`setUpWithError()`, `tearDownWithError()`).

---

### Verifying the Checkout Flow

**Scenario:** Ensure that adding an item to the cart and proceeding to checkout displays the correct product details.
```Swift
import XCTest

class AppleStoreCheckoutTests: XCTestCase {

    let app = XCUIApplication()

    override func setUpWithError() throws {
        continueAfterFailure = false
        app.launch()
    }

    override func tearDownWithError() throws {
        app.terminate()
    }

    func testCheckoutFlow() throws {
        // Navigate to a product
        let productCell = app.cells["productCell_iPhone15Pro"]
        XCTAssertTrue(productCell.waitForExistence(timeout: 5), "Product should be visible")
        productCell.tap()
        
        // Tap "Add to Bag"
        let addToBagButton = app.buttons["addToBagButton"]
        XCTAssertTrue(addToBagButton.exists, "Add to Bag button should be available")
        addToBagButton.tap()

        // Go to the Cart
        let cartButton = app.buttons["cartButton"]
        XCTAssertTrue(cartButton.exists, "Cart button should be available")
        cartButton.tap()

        // Verify item in the cart
        let cartItem = app.staticTexts["cartItem_iPhone15Pro"]
        XCTAssertTrue(cartItem.exists, "Cart should contain the added product")

        // Proceed to checkout
        let checkoutButton = app.buttons["checkoutButton"]
        XCTAssertTrue(checkoutButton.exists, "Checkout button should be available")
        checkoutButton.tap()

        // Verify checkout screen
        let checkoutTitle = app.staticTexts["Checkout"]
        XCTAssertTrue(checkoutTitle.exists, "Checkout page should be displayed")
    }
}
```

* Uses explicit **accessibility identifiers** (`productCell_iPhone15Pro`, `cartButton`).
* Implements **end-to-end flow**: from product selection to checkout.
* Ensures product details persist across the checkout journey.

### Validating Sign-In and Account Access

**Scenario:** Ensure that a user can sign in and access their account details in the Apple Store app.

```Swift
import XCTest

class AppleStoreAccountTests: XCTestCase {

    let app = XCUIApplication()

    override func setUpWithError() throws {
        continueAfterFailure = false
        app.launch()
    }

    override func tearDownWithError() throws {
        app.terminate()
    }

    func testUserSignIn() throws {
        // Tap on Account tab
        let accountTab = app.buttons["accountTab"]
        XCTAssertTrue(accountTab.exists, "Account tab should be available")
        accountTab.tap()
        
        // Tap Sign In button
        let signInButton = app.buttons["signInButton"]
        XCTAssertTrue(signInButton.exists, "Sign-in button should be available")
        signInButton.tap()

        // Enter credentials
        let emailField = app.textFields["emailTextField"]
        let passwordField = app.secureTextFields["passwordTextField"]
        
        XCTAssertTrue(emailField.exists, "Email input should be available")
        XCTAssertTrue(passwordField.exists, "Password input should be available")

        emailField.tap()
        emailField.typeText("testuser@apple.com")
        
        passwordField.tap()
        passwordField.typeText("TestPassword123")

        // Tap Sign In
        let submitButton = app.buttons["submitSignInButton"]
        XCTAssertTrue(submitButton.exists, "Submit button should be available")
        submitButton.tap()

        // Verify account is logged in
        let welcomeMessage = app.staticTexts["welcomeMessage"]
        XCTAssertTrue(welcomeMessage.waitForExistence(timeout: 5), "User should be signed in successfully")
    }
}

```

* Implements authentication test with **email and password fields**.
* Verifies successful sign-in by checking a **welcome message**.
* Uses `secureTextFields` for password security.

### **Best Practices for Writing Effective XCUITests**

1. **Use Accessibility Identifiers**: Assign meaningful `accessibilityIdentifier` values in the app's UI to improve test reliability.

2. **Ensure Elements Exist Before Interacting**: Use `waitForExistence(timeout:)` before interacting with UI elements.

3. **Minimize Dependencies Between Tests**: Each test should start from a fresh state and not depend on the outcome of another test.

4. **Run on Multiple Devices**: Validate tests on different screen sizes (iPhone SE, iPhone Pro Max, etc.).

5. **Keep Tests Focused and Modular**: A single test should cover one feature without excessive navigation.

